namespace core;

@TargetOS("windows")
public func STDIn() #File {
    return #File.init(__acrt_iob_func(0));
}

@TargetOS("windows")
public func STDOut() #File {
    return #File.init(__acrt_iob_func(1));
}

@TargetOS("windows")
public func STDErr() #File {
    return #File.init(__acrt_iob_func(2));
}

@TargetOS("linux")
public func STDIn() #File {
    return #File.init(stdin);
}

@TargetOS("linux")
public func STDOut() #File {
    return #File.init(stdout);
}

@TargetOS("linux")
public func STDErr() #File {
    return #File.init(stderr);
}

@TargetOS("linux")
public func Exit() {
    pthread_exit(null);
    return;
}

public func EOF(ch #i32) #bool {
    return ch < 0;
}

public func Write(char #u8) {
    STDOut().Write(char);
    return;
}

public func Write(string #u8*) {
    STDOut().Write(string);
    return;
}

public func Write(string #u8*, end #u8) {
    STDOut().Write(string, end);
    return;
}

public func WriteLine(string #u8*) {
    STDOut().WriteLine(string);
    return;
}

public func Input(string #u8*) #u8* {
    return Input(string, STDOut(), STDIn());
}

public func Input(string #u8*, output #File, input #File) #u8* {
    output.Write(string, '\0');
    return input.ReadLine();
}

public func OpenFile(path #u8*, mode #u8*) #File {
    return #File.init(fopen(path, mode));
}

public struct File {
    public CFile #FILE*;

    public static func init(cfile #FILE*) #File {
        self.CFile = cfile;
        return self;
    }

    public func Write(string #u8*) {
        fputs(string, self.CFile);
        fflush(self.CFile);
        return;
    }

    public func Write(char #u8) {
        local str #u8* = #u8*(malloc(1));
        sprintf(str, "%c", char);
        self.Write(str);
        return;
    }

    public func Write(string #u8*, end #u8) {
        self.Write(string)
        self.Write(end);
        return;
    }

    public func WriteLine(string #u8*) {
        self.Write(string, '\n');
        return;
    }

    public func GetChar() #u8 {
        local ch #i32 = fgetc(self.CFile);

        if !EOF(ch) {
            return #u8(ch);
        } else {
            return '\0';
        }
    }

    public func ReadLine() #u8* {
        local size #u32 = 512;
        local string #u8* = malloc(size);
        local ch #u8;
        local len #u32 = 0;

        if string == null {
            return string;
        }

        while (ch = self.GetChar()) != '\0' and ch != '\n' {
            string[len] = ch;
            ++len;
            
            if len >= size {
                string = realloc(string, size += 512);

                if string == null {
                    return string;
                }
            }
        }

        string[++len] = '\0';
        string = realloc(string, ++len);
        return string;
    }
}

public struct Thread {
    public pthread_t #u64;
    pthread_attr_t #void*;
    pthread_main #(#void*) #void*;
    pthread_arg #void*;

    public static func init(main #(#void*) #void*, argument #void*) #Thread {
        self.pthread_main = main;
        self.pthread_arg = argument;
        return self;
    }
    
    public func Start() {
        //this (the i32 type) should throw a compiler error
        //self.pthread_id #i32 = pthread_create(self.pthread_t, self.pthread_attr_t, self.pthread_main, self.pthread_arg);
        if pthread_create(&self.pthread_t, self.pthread_attr_t, self.pthread_main, self.pthread_arg) != 0 {
            STDErr().WriteLine("Failed to start thread.");
        }

        return;
    }

    public func Join() {
        local ret #void*;

        if pthread_join(self.pthread_t, &ret) != 0 {
            STDErr().WriteLine("Failed to join thread.");
        }

        return;
    }
}